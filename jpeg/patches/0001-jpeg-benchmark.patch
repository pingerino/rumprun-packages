From cc6446088fb887e2980948df599a43755fe5acd4 Mon Sep 17 00:00:00 2001
From: Anna Lyons <Anna.Lyons@data61.csiro.au>
Date: Thu, 19 Oct 2017 14:48:19 +1100
Subject: [PATCH 4/4] jpeg patch

---
 consumer/jpeg/jpeg-6a/Makefile      |  15 +-
 consumer/jpeg/jpeg-6a/Makefile.orig | 274 ++++++++++++++++++++++++++++++++++++
 consumer/jpeg/jpeg-6a/cdjpeg.h      |   3 +
 consumer/jpeg/jpeg-6a/cjpeg         | Bin 0 -> 221384 bytes
 consumer/jpeg/jpeg-6a/cjpeg.c       | 162 ++++++++++++++++++++-
 consumer/jpeg/jpeg-6a/djpeg.c       |   5 +-
 consumer/jpeg/jpeg-6a/jpegtran      | Bin 0 -> 104536 bytes
 consumer/jpeg/jpeg-6a/libjpeg.a     | Bin 0 -> 216658 bytes
 consumer/jpeg/jpeg-6a/rdjpgcom      | Bin 0 -> 11040 bytes
 consumer/jpeg/jpeg-6a/wrjpgcom      | Bin 0 -> 11296 bytes
 10 files changed, 445 insertions(+), 14 deletions(-)
 create mode 100755 consumer/jpeg/jpeg-6a/Makefile.orig
 create mode 100755 consumer/jpeg/jpeg-6a/cjpeg
 create mode 100755 consumer/jpeg/jpeg-6a/jpegtran
 create mode 100644 consumer/jpeg/jpeg-6a/libjpeg.a
 create mode 100755 consumer/jpeg/jpeg-6a/rdjpgcom
 create mode 100755 consumer/jpeg/jpeg-6a/wrjpgcom

diff --git a/jpeg-6a/Makefile b/jpeg-6a/Makefile
index ce0c45f..807ebc9 100755
--- a/jpeg-6a/Makefile
+++ b/jpeg-6a/Makefile
@@ -20,20 +20,20 @@ manext = 1
 mandir = $(prefix)/man/man$(manext)
 
 # The name of your C compiler:
-CC= gcc
+CC= $(RUMPRUN_CC)
 
 # You may need to adjust these cc options:
-CFLAGS= -O  -I$(srcdir)
+CFLAGS= -O  -I$(srcdir) -I../../include
 # Generally, we recommend defining any configuration symbols in jconfig.h,
 # NOT via -D switches here.
 # However, any special defines for ansi2knr.c may be included here:
-ANSI2KNRFLAGS= 
+ANSI2KNRFLAGS=
 
 # Link-time cc options:
-LDFLAGS= 
+LDFLAGS=
 
 # To link any special libraries, add the necessary -l commands here.
-LDLIBS= 
+LDLIBS=
 
 # Put here the object file name for the correct system-dependent memory
 # manager file.  For Unix this is usually jmemnobs.o, but you may want
@@ -109,14 +109,15 @@ DLIBOBJECTS= jdapimin.o jdapistd.o jdtrans.o jdatasrc.o jdmaster.o \
 # These objectfiles are included in libjpeg.a
 LIBOBJECTS= $(CLIBOBJECTS) $(DLIBOBJECTS) $(COMOBJECTS)
 # object files for sample applications (excluding library files)
-COBJECTS= cjpeg.o rdppm.o rdgif.o rdtarga.o rdrle.o rdbmp.o rdswitch.o \
+COBJECTS= cjpeg.o djpeg.o rdppm.o rdgif.o rdtarga.o rdrle.o rdbmp.o rdswitch.o \
+		  wrppm.o wrgif.o wrtarga.o wrrle.o wrbmp.o rdcolmap.o \
         cdjpeg.o
 DOBJECTS= djpeg.o wrppm.o wrgif.o wrtarga.o wrrle.o wrbmp.o rdcolmap.o \
         cdjpeg.o
 TROBJECTS= jpegtran.o rdswitch.o cdjpeg.o
 
 
-all:  libjpeg.a cjpeg djpeg jpegtran rdjpgcom wrjpgcom
+all:  libjpeg.a cjpeg
 
 # This rule causes ansi2knr to be invoked.
 # .c.o:
diff --git a/jpeg-6a/cdjpeg.h b/jpeg-6a/cdjpeg.h
index cc0d600..887b33e 100755
--- a/jpeg-6a/cdjpeg.h
+++ b/jpeg-6a/cdjpeg.h
@@ -150,6 +150,9 @@ EXTERN(boolean) keymatch JPP((char * arg, const char * keyword, int minchars));
 EXTERN(FILE *) read_stdin JPP((void));
 EXTERN(FILE *) write_stdout JPP((void));
 
+int djpeg_main (int argc, char **argv);
+int cjpeg_main (int argc, char **argv);
+
 /* miscellaneous useful macros */
 
 #ifdef DONT_USE_B_MODE		/* define mode parameters for fopen() */
iff --git a/jpeg-6a/cjpeg.c b/jpeg-6a/cjpeg.c
index 194d93b..64beeab 100755
--- a/jpeg-6a/cjpeg.c
+++ b/jpeg-6a/cjpeg.c
@@ -22,7 +22,7 @@
  *	cjpeg [options]  -outfile outputfile  inputfile
  * works regardless of which command line style is used.
  */
-
+#include <assert.h>
 #include "cdjpeg.h"		/* Common decls for cjpeg/djpeg applications */
 #include "jversion.h"		/* for version message */
 
@@ -36,6 +36,7 @@
 #endif
 #endif
 
+#include <sel4/sel4.h>
 
 /* Create the add-on message string table. */
 
@@ -458,7 +459,7 @@ parse_switches (j_compress_ptr cinfo, int argc, char **argv,
  */
 
 int
-main (int argc, char **argv)
+cjpeg_main (int argc, char **argv)
 {
   struct jpeg_compress_struct cinfo;
   struct jpeg_error_mgr jerr;
@@ -601,6 +602,159 @@ main (int argc, char **argv)
 #endif
 
   /* All done. */
-  exit(jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);
-  return 0;			/* suppress no-return-value warnings */
+  return jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS;
+}
+
+#define NS_IN_S 1000000000
+
+
+/* serialised read of the tsc. This will execute in order and no memory loads will be executed
+ * beforehand */
+static inline uint64_t
+rdtsc_cpuid(void)
+{
+
+    uint32_t high, low;
+
+    __asm__ __volatile__ (
+        "movl $0, %%eax \n"
+        "movl $0, %%ecx \n"
+        "cpuid          \n"
+        "rdtsc          \n"
+        "movl %%edx, %0 \n"
+        "movl %%eax, %1 \n"
+        "movl $0, %%eax \n"
+        "movl $0, %%ecx \n"
+        "cpuid          \n"
+        : "=r" (high), "=r" (low)
+        : /* no inputs */
+        : "eax", "ebx", "ecx", "edx"
+    );
+
+    return ((uint64_t) high) << 32llu | (uint64_t) low;
+}
+
+#define SET_TIMEOUT 2
+#define TIMEOUT_PERIODIC 0
+
+/* This function can be used to calculate ((a * b) / c) without causing
+ * overflow by doing (a * b). It also allows you to avoid loss of precision
+ * if you attempte to rearrange the algorithm to (a * (c / b))
+ * It is essentially the Ancient Egyption Multiplication
+ * with (a * (b / c)) but we keep (b / c) in quotient+remainder
+ * form to not lose precision.
+ * This function only works with unsigned 64bit types. It can be
+ * trivially abstracted to other sizes. Dealing with signed is possible
+ * but not included here */
+static inline uint64_t muldivu64(uint64_t a, uint64_t b, uint64_t c)
+{
+    /* quotient and remainder of the final calculation */
+    uint64_t quotient = 0;
+    uint64_t remainder = 0;
+    /* running quotient and remainder of the current power of two
+     * bit we are looking at. As we look at the different bits
+     * of a we will increase these */
+    uint64_t cur_quotient = b / c;
+    uint64_t cur_remainder = b % c;
+    /* we will iterate through all the bits of a from least to most
+     * significant, we can stop early once there are no set bits though */
+    while (a) {
+        /* If this bit is set then the power of two is part of the
+         * construction of a */
+        if (a & 1) {
+            /* increase final quotient, taking care of any remainder */
+            quotient += cur_quotient;
+            remainder += cur_remainder;
+            if (remainder >= c) {
+                quotient++;
+                remainder -= c;
+            }
+        }
+        /* Go to the next bit of a. Also means the effective quotient
+         * and remainder of our (b / c) needs increasing */
+        a >>= 1;
+        cur_quotient <<= 1;
+        cur_remainder <<= 1;
+        /* Keep the remainder sensible, otherewise the remainder check
+         * in the if (a & 1) case has to become a loop */
+        if (cur_remainder >= c) {
+            cur_quotient++;
+            cur_remainder -= c;
+        }
+    }
+    return quotient;
+}
+
+static inline uint64_t tsc_get_time(uint64_t freq)
+{
+    return muldivu64(rdtsc_cpuid(), NS_IN_S, freq);
+}
+
+
+int main (int argc, char **argv)
+{
+
+    volatile int *stage = (int *) atol(argv[1]);
+    uint64_t period = atol(argv[2]);
+    seL4_CPtr ep = atol(argv[3]);
+    seL4_CPtr signal = atol(argv[4]);
+    uint64_t freq = atol(argv[5]);
+    uint64_t *results = (uint64_t *) atol(argv[6]);
+
+    assert(*stage == 0);
+
+    char *cjpeg_argv[] = {
+        "cjpeg",
+        "-dct",
+        "int",
+        "-progressive",
+        "-opt",
+        "-outfile",
+        "/tmp/output_large_encode.jpeg",
+        "/data/jpeg/input_large.ppm"
+    };
+
+
+    char *djpeg_argv[] = {
+        "djpeg",
+        "-dct",
+        "int",
+        "-ppm",
+        "-outfile",
+        "/tmp/output_large_decode.ppm",
+        "/data/jpeg/input_large.jpg"
+    };
+
+
+    seL4_SetMR(0, SET_TIMEOUT);
+    seL4_SetMR(1, TIMEOUT_PERIODIC);
+    seL4_SetMR(2, period);
+    seL4_Call(ep, seL4_MessageInfo_new(0xF00, 0, 0, 3));
+
+    seL4_Wait(signal, NULL);
+
+    /* wait for the start signal */
+    int i = 0;
+    int ret = 0;
+    while (*stage < 3) {
+        results[i] = tsc_get_time(freq);
+        i++;
+
+        ret |= cjpeg_main(8, cjpeg_argv);
+        if (*stage >= 1) {
+            ret |= cjpeg_main(8, cjpeg_argv);
+            for (int k = 0; k < 5; k++) {
+                ret |= djpeg_main(7, djpeg_argv);
+            }
+        }
+
+        results[i] = tsc_get_time(freq);
+        i++;
+        results[i] = *stage;
+        i++;
+        seL4_Wait(signal, NULL);
+        assert(i < 262144);
+    }
+
+    return ret;
 }
diff --git a/jpeg-6a/djpeg.c b/jpeg-6a/djpeg.c
index 5465994..a12b2f4 100755
--- a/jpeg-6a/djpeg.c
+++ b/jpeg-6a/djpeg.c
@@ -416,7 +416,7 @@ COM_handler (j_decompress_ptr cinfo)
  */
 
 int
-main (int argc, char **argv)
+djpeg_main (int argc, char **argv)
 {
   struct jpeg_decompress_struct cinfo;
   struct jpeg_error_mgr jerr;
@@ -599,6 +599,5 @@ main (int argc, char **argv)
 #endif
 
   /* All done. */
-  exit(jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS);
-  return 0;			/* suppress no-return-value warnings */
+  return jerr.num_warnings ? EXIT_WARNING : EXIT_SUCCESS;			/* suppress no-return-value warnings */
 }
