diff -u b/susan.c a/susan.c
--- a/susan.c	2001-10-17 12:57:00.000000000 +1000
+++ b/susan.c	2018-02-20 15:19:00.733312524 +1100
@@ -192,7 +192,7 @@
 
   SGI      IRIX       SGI cc
 
-  DEC      Unix V3.2+ 
+  DEC      Unix V3.2+
 
   IBM RISC AIX        gcc
 
@@ -295,6 +295,8 @@
 #define SEVEN_SUPP           /* size for non-max corner suppression; SEVEN_SUPP or FIVE_SUPP */
 #define MAX_CORNERS   15000  /* max corners per frame */
 
+#include <sel4/sel4.h>
+
 /* ********** Leave the rest - but you may need to remove one or both of sys/file.h and malloc.h lines */
 
 #include <stdlib.h>
@@ -303,6 +305,8 @@
 #include <math.h>
 #include <sys/file.h>    /* may want to remove this line */
 #include <malloc.h>      /* may want to remove this line */
+#include <assert.h>
+
 #define  exit_error(IFB,IFC) { fprintf(stderr,IFB,IFC); exit(0); }
 #define  FTOI(a) ( (a) < 0 ? ((int)(a-0.5)) : ((int)(a+0.5)) )
 typedef  unsigned char uchar;
@@ -419,20 +423,21 @@
 FILE  *fd;
 
 #ifdef FOPENB
-  if ((fd=fopen(filename,"wb")) == NULL) 
+  if ((fd=fopen(filename,"wb")) == NULL)
 #else
-  if ((fd=fopen(filename,"w")) == NULL) 
+  if ((fd=fopen(filename,"w")) == NULL)
 #endif
     exit_error("Can't output image%s.\n",filename);
 
   fprintf(fd,"P5\n");
   fprintf(fd,"%d %d\n",x_size,y_size);
   fprintf(fd,"255\n");
-  
+
   if (fwrite(in,x_size*y_size,1,fd) != 1)
     exit_error("Can't write image %s.\n",filename);
 
   fclose(fd);
+  free(in);
 }
 
 /* }}} */
@@ -465,7 +470,7 @@
 /* }}} */
 /* {{{ setup_brightness_lut(bp,thresh,form) */
 
-void setup_brightness_lut(bp,thresh,form)
+void *setup_brightness_lut(bp,thresh,form)
   uchar **bp;
   int   thresh, form;
 {
@@ -473,6 +478,7 @@
 float temp;
 
   *bp=(unsigned char *)malloc(516);
+  void *malloced = *bp;
   *bp=*bp+258;
 
   for(k=-256;k<257;k++)
@@ -484,6 +490,8 @@
     temp=100.0*exp(-temp);
     *(*bp+k)= (uchar)temp;
   }
+
+  return malloced;
 }
 
 /* }}} */
@@ -510,7 +518,7 @@
       n+=*(cp-*p++);
       n+=*(cp-*p++);
       n+=*(cp-*p);
-      p+=x_size-3; 
+      p+=x_size-3;
 
       n+=*(cp-*p++);
       n+=*(cp-*p++);
@@ -586,7 +594,7 @@
       n+=*(cp-*p++);
       n+=*(cp-*p++);
       n+=*(cp-*p);
-      p+=x_size-2; 
+      p+=x_size-2;
 
       n+=*(cp-*p);
       p+=2;
@@ -802,6 +810,9 @@
 
 /* }}} */
   }
+
+  free(dp);
+  free(tmp_image);
 }
 
 /* }}} */
@@ -824,7 +835,7 @@
     midp=mid;
     for (i=0; i<x_size*y_size; i++)
     {
-      if (*midp<8) 
+      if (*midp<8)
       {
         inp = in + (midp - mid) - x_size - 1;
         *inp++=255; *inp++=255; *inp=255; inp+=x_size-2;
@@ -839,7 +850,7 @@
   midp=mid;
   for (i=0; i<x_size*y_size; i++)
   {
-    if (*midp<8) 
+    if (*midp<8)
       *(in + (midp - mid)) = 0;
     midp++;
   }
@@ -903,21 +914,21 @@
           l[3]=r[(i  )*x_size+j-1]; l[4]=0;                 l[5]=r[(i  )*x_size+j+1];
           l[6]=r[(i+1)*x_size+j-1]; l[7]=r[(i+1)*x_size+j]; l[8]=r[(i+1)*x_size+j+1];
 
-          if (mid[(i-1)*x_size+j-1]<8)        { l[0]=0; l[1]=0; l[3]=0; l[2]*=2; 
+          if (mid[(i-1)*x_size+j-1]<8)        { l[0]=0; l[1]=0; l[3]=0; l[2]*=2;
                                                 l[6]*=2; l[5]*=3; l[7]*=3; l[8]*=4; }
-          else { if (mid[(i-1)*x_size+j]<8)   { l[1]=0; l[0]=0; l[2]=0; l[3]*=2; 
+          else { if (mid[(i-1)*x_size+j]<8)   { l[1]=0; l[0]=0; l[2]=0; l[3]*=2;
                                                 l[5]*=2; l[6]*=3; l[8]*=3; l[7]*=4; }
-          else { if (mid[(i-1)*x_size+j+1]<8) { l[2]=0; l[1]=0; l[5]=0; l[0]*=2; 
+          else { if (mid[(i-1)*x_size+j+1]<8) { l[2]=0; l[1]=0; l[5]=0; l[0]*=2;
                                                 l[8]*=2; l[3]*=3; l[7]*=3; l[6]*=4; }
-          else { if (mid[(i)*x_size+j-1]<8)   { l[3]=0; l[0]=0; l[6]=0; l[1]*=2; 
+          else { if (mid[(i)*x_size+j-1]<8)   { l[3]=0; l[0]=0; l[6]=0; l[1]*=2;
                                                 l[7]*=2; l[2]*=3; l[8]*=3; l[5]*=4; }
-          else { if (mid[(i)*x_size+j+1]<8)   { l[5]=0; l[2]=0; l[8]=0; l[1]*=2; 
+          else { if (mid[(i)*x_size+j+1]<8)   { l[5]=0; l[2]=0; l[8]=0; l[1]*=2;
                                                 l[7]*=2; l[0]*=3; l[6]*=3; l[3]*=4; }
-          else { if (mid[(i+1)*x_size+j-1]<8) { l[6]=0; l[3]=0; l[7]=0; l[0]*=2; 
+          else { if (mid[(i+1)*x_size+j-1]<8) { l[6]=0; l[3]=0; l[7]=0; l[0]*=2;
                                                 l[8]*=2; l[1]*=3; l[5]*=3; l[2]*=4; }
-          else { if (mid[(i+1)*x_size+j]<8)   { l[7]=0; l[6]=0; l[8]=0; l[3]*=2; 
+          else { if (mid[(i+1)*x_size+j]<8)   { l[7]=0; l[6]=0; l[8]=0; l[3]*=2;
                                                 l[5]*=2; l[0]*=3; l[2]*=3; l[1]*=4; }
-          else { if (mid[(i+1)*x_size+j+1]<8) { l[8]=0; l[5]=0; l[7]=0; l[6]*=2; 
+          else { if (mid[(i+1)*x_size+j+1]<8) { l[8]=0; l[5]=0; l[7]=0; l[6]*=2;
                                                 l[2]*=2; l[1]*=3; l[3]*=3; l[0]*=4; } }}}}}}}
 
           m=0;     /* find the highest point */
@@ -956,7 +967,7 @@
                 e.g. X O X  CAN  become X X X
                      O X O              O O O
                      O O O              O O O    */
-            if (b00) 
+            if (b00)
 	    {
               if (b02) { x=0; y=-1; }
               else     { x=-1; y=0; }
@@ -1081,7 +1092,7 @@
       n+=*(cp-*p++);
       n+=*(cp-*p++);
       n+=*(cp-*p);
-      p+=x_size-3; 
+      p+=x_size-3;
 
       n+=*(cp-*p++);
       n+=*(cp-*p++);
@@ -1149,15 +1160,15 @@
           c=*(cp-*p++);x-=c;y-=3*c;
           c=*(cp-*p++);y-=3*c;
           c=*(cp-*p);x+=c;y-=3*c;
-          p+=x_size-3; 
-    
+          p+=x_size-3;
+
           c=*(cp-*p++);x-=2*c;y-=2*c;
           c=*(cp-*p++);x-=c;y-=2*c;
           c=*(cp-*p++);y-=2*c;
           c=*(cp-*p++);x+=c;y-=2*c;
           c=*(cp-*p);x+=2*c;y-=2*c;
           p+=x_size-5;
-    
+
           c=*(cp-*p++);x-=3*c;y-=c;
           c=*(cp-*p++);x-=2*c;y-=c;
           c=*(cp-*p++);x-=c;y-=c;
@@ -1175,7 +1186,7 @@
           c=*(cp-*p++);x+=2*c;
           c=*(cp-*p);x+=3*c;
           p+=x_size-6;
-    
+
           c=*(cp-*p++);x-=3*c;y+=c;
           c=*(cp-*p++);x-=2*c;y+=c;
           c=*(cp-*p++);x-=c;y+=c;
@@ -1217,11 +1228,11 @@
           else
             do_symmetry=1;
         }
-        else 
+        else
           do_symmetry=1;
 
         if (do_symmetry==1)
-	{ 
+	{
           p=in + (i-3)*x_size + j - 1;
           x=0; y=0; w=0;
 
@@ -1232,15 +1243,15 @@
           c=*(cp-*p++);x+=c;y+=9*c;w+=3*c;
           c=*(cp-*p++);y+=9*c;
           c=*(cp-*p);x+=c;y+=9*c;w-=3*c;
-          p+=x_size-3; 
-  
+          p+=x_size-3;
+
           c=*(cp-*p++);x+=4*c;y+=4*c;w+=4*c;
           c=*(cp-*p++);x+=c;y+=4*c;w+=2*c;
           c=*(cp-*p++);y+=4*c;
           c=*(cp-*p++);x+=c;y+=4*c;w-=2*c;
           c=*(cp-*p);x+=4*c;y+=4*c;w-=4*c;
           p+=x_size-5;
-    
+
           c=*(cp-*p++);x+=9*c;y+=c;w+=3*c;
           c=*(cp-*p++);x+=4*c;y+=c;w+=2*c;
           c=*(cp-*p++);x+=c;y+=c;w+=c;
@@ -1258,7 +1269,7 @@
           c=*(cp-*p++);x+=4*c;
           c=*(cp-*p);x+=9*c;
           p+=x_size-6;
-    
+
           c=*(cp-*p++);x+=9*c;y+=c;w-=3*c;
           c=*(cp-*p++);x+=4*c;y+=c;w-=2*c;
           c=*(cp-*p++);x+=c;y+=c;w-=c;
@@ -1267,7 +1278,7 @@
           c=*(cp-*p++);x+=4*c;y+=c;w+=2*c;
           c=*(cp-*p);x+=9*c;y+=c;w+=3*c;
           p+=x_size-5;
- 
+
           c=*(cp-*p++);x+=4*c;y+=4*c;w-=4*c;
           c=*(cp-*p++);x+=c;y+=4*c;w-=2*c;
           c=*(cp-*p++);y+=4*c;
@@ -1289,7 +1300,7 @@
                                 else { a=1; b=1; }}}
           if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) &&
                (m > r[(i+(2*a))*x_size+j+(2*b)]) && (m >= r[(i-(2*a))*x_size+j-(2*b)]) )
-            mid[i*x_size+j] = 2;	
+            mid[i*x_size+j] = 2;
         }
       }
     }
@@ -1320,7 +1331,7 @@
       n+=*(cp-*p++);
       n+=*(cp-*p++);
       n+=*(cp-*p);
-      p+=x_size-2; 
+      p+=x_size-2;
 
       n+=*(cp-*p);
       p+=2;
@@ -1352,7 +1363,7 @@
           c=*(cp-*p++);x-=c;y-=c;
           c=*(cp-*p++);y-=c;
           c=*(cp-*p);x+=c;y-=c;
-          p+=x_size-2; 
+          p+=x_size-2;
 
           c=*(cp-*p);x-=c;
           p+=2;
@@ -1387,7 +1398,7 @@
           do_symmetry=1;
 
         if (do_symmetry==1)
-	{ 
+	{
           p=in + (i-1)*x_size + j - 1;
           x=0; y=0; w=0;
 
@@ -1398,7 +1409,7 @@
           c=*(cp-*p++);x+=c;y+=c;w+=c;
           c=*(cp-*p++);y+=c;
           c=*(cp-*p);x+=c;y+=c;w-=c;
-          p+=x_size-2; 
+          p+=x_size-2;
 
           c=*(cp-*p);x+=c;
           p+=2;
@@ -1418,7 +1429,7 @@
           else { /* diagonal */ if (w>0) { a=-1; b=1; }
                                 else { a=1; b=1; }}}
           if ( (m > r[(i+a)*x_size+j+b]) && (m >= r[(i-a)*x_size+j-b]) )
-            mid[i*x_size+j] = 2;	
+            mid[i*x_size+j] = 2;
         }
       }
     }
@@ -1485,7 +1496,7 @@
         n+=*(cp-*p++);
         n+=*(cp-*p++);
         n+=*(cp-*p);
-        p+=x_size-3; 
+        p+=x_size-3;
 
         n+=*(cp-*p++);
         n+=*(cp-*p++);
@@ -1558,15 +1569,15 @@
             c=*(cp-*p++);x-=c;y-=3*c;
             c=*(cp-*p++);y-=3*c;
             c=*(cp-*p);x+=c;y-=3*c;
-            p+=x_size-3; 
-    
+            p+=x_size-3;
+
             c=*(cp-*p++);x-=2*c;y-=2*c;
             c=*(cp-*p++);x-=c;y-=2*c;
             c=*(cp-*p++);y-=2*c;
             c=*(cp-*p++);x+=c;y-=2*c;
             c=*(cp-*p);x+=2*c;y-=2*c;
             p+=x_size-5;
-    
+
             c=*(cp-*p++);x-=3*c;y-=c;
             c=*(cp-*p++);x-=2*c;y-=c;
             c=*(cp-*p++);x-=c;y-=c;
@@ -1584,7 +1595,7 @@
             c=*(cp-*p++);x+=2*c;
             c=*(cp-*p);x+=3*c;
             p+=x_size-6;
-    
+
             c=*(cp-*p++);x-=3*c;y+=c;
             c=*(cp-*p++);x-=2*c;y+=c;
             c=*(cp-*p++);x-=c;y+=c;
@@ -1666,7 +1677,7 @@
 	      (x>=r[(i+1)*x_size+j-2]) )
 #endif
 #ifdef SEVEN_SUPP
-          if ( 
+          if (
                 (x>r[(i-3)*x_size+j-3]) &&
                 (x>r[(i-3)*x_size+j-2]) &&
                 (x>r[(i-3)*x_size+j-1]) &&
@@ -1867,7 +1878,7 @@
 	      (x>=r[(i+1)*x_size+j-2]) )
 #endif
 #ifdef SEVEN_SUPP
-          if ( 
+          if (
                 (x>r[(i-3)*x_size+j-3]) &&
                 (x>r[(i-3)*x_size+j-2]) &&
                 (x>r[(i-3)*x_size+j-1]) &&
@@ -1959,7 +1970,7 @@
 /* }}} */
 /* {{{ main(argc, argv) */
 
-main(argc, argv)
+susan_main(argc, argv)
   int   argc;
   char  *argv [];
 {
@@ -2036,7 +2047,7 @@
 	    exit(0);}
 	  bt=atoi(argv[argindex]);
 	  break;
-      }	    
+      }
       else
         usage();
     argindex++;
@@ -2048,13 +2059,15 @@
 /* }}} */
   /* {{{ main processing */
 
+  void *m;
   switch (mode)
   {
     case 0:
       /* {{{ smoothing */
 
-      setup_brightness_lut(&bp,bt,2);
+      m = setup_brightness_lut(&bp,bt,2);
       susan_smoothing(three_by_three,in,dt,x_size,y_size,bp);
+      free(m);
       break;
 
 /* }}} */
@@ -2062,7 +2075,7 @@
       /* {{{ edges */
 
       r   = (int *) malloc(x_size * y_size * sizeof(int));
-      setup_brightness_lut(&bp,bt,6);
+      m = setup_brightness_lut(&bp,bt,6);
 
       if (principle)
       {
@@ -2084,8 +2097,11 @@
         if(thin_post_proc)
           susan_thin(r,mid,x_size,y_size);
         edge_draw(in,mid,x_size,y_size,drawing_mode);
+        free(mid);
       }
 
+      free(r);
+      free(m);
       break;
 
 /* }}} */
@@ -2093,7 +2109,7 @@
       /* {{{ corners */
 
       r   = (int *) malloc(x_size * y_size * sizeof(int));
-      setup_brightness_lut(&bp,bt,6);
+      m = setup_brightness_lut(&bp,bt,6);
 
       if (principle)
       {
@@ -2109,10 +2125,12 @@
         corner_draw(in,corner_list,x_size,drawing_mode);
       }
 
+      free(r);
+      free(m);
       break;
 
 /* }}} */
-  }    
+  }
 
 /* }}} */
 
@@ -2120,3 +2138,170 @@
 }
 
 /* }}} */
+
+#define NS_IN_S 1000000000
+
+/* serialised read of the tsc. This will execute in order and no memory loads will be executed
+ * beforehand */
+static inline uint64_t
+rdtsc_cpuid(void)
+{
+
+    uint32_t high, low;
+
+    __asm__ __volatile__ (
+        "movl $0, %%eax \n"
+        "movl $0, %%ecx \n"
+        "cpuid          \n"
+        "rdtsc          \n"
+        "movl %%edx, %0 \n"
+        "movl %%eax, %1 \n"
+        "movl $0, %%eax \n"
+        "movl $0, %%ecx \n"
+        "cpuid          \n"
+        : "=r" (high), "=r" (low)
+        : /* no inputs */
+        : "eax", "ebx", "ecx", "edx"
+    );
+
+    return ((uint64_t) high) << 32llu | (uint64_t) low;
+}
+
+char *input = "/data/susan/input_large.pgm";
+char *smooth_out = "/tmp/output_large.smoothing.pgm";
+char *edges_out = "/tmp/output_large.edges.pgm";
+char *corners_out = "/tmp/output_large.corners.pgm";
+char *smooth_flag = "-s";
+char *edges_flag = "-e";
+char *corner_flag = "-c";
+char *binary = "susan";
+
+#define SET_TIMEOUT 2
+#define TIMEOUT_PERIODIC 0
+
+
+/* This function can be used to calculate ((a * b) / c) without causing
+ * overflow by doing (a * b). It also allows you to avoid loss of precision
+ * if you attempte to rearrange the algorithm to (a * (c / b))
+ * It is essentially the Ancient Egyption Multiplication
+ * with (a * (b / c)) but we keep (b / c) in quotient+remainder
+ * form to not lose precision.
+ * This function only works with unsigned 64bit types. It can be
+ * trivially abstracted to other sizes. Dealing with signed is possible
+ * but not included here */
+static inline uint64_t muldivu64(uint64_t a, uint64_t b, uint64_t c)
+{
+    /* quotient and remainder of the final calculation */
+    uint64_t quotient = 0;
+    uint64_t remainder = 0;
+    /* running quotient and remainder of the current power of two
+     * bit we are looking at. As we look at the different bits
+     * of a we will increase these */
+    uint64_t cur_quotient = b / c;
+    uint64_t cur_remainder = b % c;
+    /* we will iterate through all the bits of a from least to most
+     * significant, we can stop early once there are no set bits though */
+    while (a) {
+        /* If this bit is set then the power of two is part of the
+         * construction of a */
+        if (a & 1) {
+            /* increase final quotient, taking care of any remainder */
+            quotient += cur_quotient;
+            remainder += cur_remainder;
+            if (remainder >= c) {
+                quotient++;
+                remainder -= c;
+            }
+        }
+        /* Go to the next bit of a. Also means the effective quotient
+         * and remainder of our (b / c) needs increasing */
+        a >>= 1;
+        cur_quotient <<= 1;
+        cur_remainder <<= 1;
+        /* Keep the remainder sensible, otherewise the remainder check
+         * in the if (a & 1) case has to become a loop */
+        if (cur_remainder >= c) {
+            cur_quotient++;
+            cur_remainder -= c;
+        }
+    }
+    return quotient;
+}
+
+static inline uint64_t tsc_get_time(uint64_t freq)
+{
+    return muldivu64(rdtsc_cpuid(), NS_IN_S, freq);
+}
+
+int main(int argc, char *argv[])
+{
+    volatile int *stage = (int *) atol(argv[1]);
+    uint64_t period = atol(argv[2]);
+    seL4_CPtr ep = atol(argv[3]);
+    seL4_CPtr signal = atol(argv[4]);
+    uint64_t freq = atol(argv[5]);
+    uint64_t *results = (uint64_t *) atol(argv[6]);
+
+    assert(*stage == 0);
+
+    char *s_argv[] = {
+        binary,
+        input,
+        smooth_out,
+        smooth_flag
+    };
+
+    char *e_argv[] = {
+        binary,
+        input,
+        edges_out,
+        edges_flag
+    };
+
+    char *c_argv[] = {
+        binary,
+        input,
+        corners_out,
+        corner_flag
+    };
+
+
+  	seL4_SetMR(0, SET_TIMEOUT);
+    seL4_SetMR(1, TIMEOUT_PERIODIC);
+    seL4_SetMR(2, period);
+    seL4_Call(ep, seL4_MessageInfo_new(0xF00, 0, 0, 3));
+
+    /* wait for the start signal */
+    seL4_Wait(signal, NULL);
+    int i = 0;
+    while (*stage < 3) {
+        uint64_t start = tsc_get_time(freq);
+        results[i] = start;
+        i++;
+
+        if (*stage >= 0) {
+            susan_main(4, s_argv);
+        }
+
+        if (*stage >= 1) {
+            for (int k = 0; k < 4; k++) {
+                susan_main(4, e_argv);
+            }
+        }
+
+        if (*stage >= 2) {
+            for (int k = 0; k < 30; k++) {
+                susan_main(4, c_argv);
+            }
+        }
+
+        results[i] = tsc_get_time(freq);
+        i++;
+        results[i] = *stage;
+        i++;
+        seL4_Wait(signal, NULL);
+        assert(i < 262144);
+    }
+
+    return 0;
+}
