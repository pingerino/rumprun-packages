--- a/mad-0.14.2b/madplay.c	2001-11-09 11:58:45.000000000 +1100
+++ b/mad-0.14.2b/madplay.c	2017-10-17 09:17:12.594392492 +1100
@@ -50,6 +50,8 @@
 # include "audio.h"
 # include "player.h"

+#include <sel4/sel4.h>
+
 # define FADE_DEFAULT	"0:05"

 # if defined(EXPERIMENTAL)
@@ -398,6 +400,8 @@
   return mad_f_tofixed(pow(10, db / 20));
 }

+#define POSIXLY_CORRECT
+
 /*
  * NAME:	get_options()
  * DESCRIPTION:	parse command-line options or die
@@ -405,7 +409,8 @@
 static
 void get_options(int argc, char *argv[], struct player *player)
 {
-  int opt, index;
+  int opt = 0;
+  int index = 0;
   int ttyset = 0;

   while ((opt = getopt_long(argc, argv,
@@ -503,8 +508,9 @@
       if (player->output.command == 0)
 	die(_("unknown output format type for \"%s\""), optarg);

-      if (!ttyset)
-	player->options &= ~PLAYER_OPTION_TTYCONTROL;
+      if (!ttyset) {
+          player->options &= ~PLAYER_OPTION_TTYCONTROL;
+      }
       break;

 # if 0
@@ -586,11 +592,11 @@
  * NAME:	main()
  * DESCRIPTION:	program entry point
  */
-int main(int argc, char *argv[])
+int mad_main(int argc, char *argv[])
 {
-  struct player player;
+  struct player player = {0};
   int result = 0;
-
+  optind = 1;
   argv0 = argv[0];

   /* internationalization support */
@@ -602,7 +608,6 @@
 # endif

   /* initialize and get options */
-
   player_init(&player);

 # if !defined(__CYGWIN__)  /* Cygwin support for this is currently buggy */
@@ -653,3 +658,136 @@

   return result;
 }
+
+
+#define NS_IN_S 1000000000
+
+/* just read the tsc. This may be executed out of order as it is unserialised */
+static inline uint64_t
+rdtsc_pure(void)
+{
+    uint32_t high, low;
+
+    __asm__ __volatile__ (
+        "rdtsc"
+        : "=a" (low),
+        "=d" (high)
+        : /* no input */
+        : /* no clobbers */
+    );
+
+    return (((uint64_t) high) << 32llu) + (uint64_t) low;
+
+}
+
+#define SET_TIMEOUT 2
+#define TIMEOUT_PERIODIC 0
+
+
+/* This function can be used to calculate ((a * b) / c) without causing
+ * overflow by doing (a * b). It also allows you to avoid loss of precision
+ * if you attempte to rearrange the algorithm to (a * (c / b))
+ * It is essentially the Ancient Egyption Multiplication
+ * with (a * (b / c)) but we keep (b / c) in quotient+remainder
+ * form to not lose precision.
+ * This function only works with unsigned 64bit types. It can be
+ * trivially abstracted to other sizes. Dealing with signed is possible
+ * but not included here */
+static inline uint64_t muldivu64(uint64_t a, uint64_t b, uint64_t c)
+{
+    /* quotient and remainder of the final calculation */
+    uint64_t quotient = 0;
+    uint64_t remainder = 0;
+    /* running quotient and remainder of the current power of two
+     * bit we are looking at. As we look at the different bits
+     * of a we will increase these */
+    uint64_t cur_quotient = b / c;
+    uint64_t cur_remainder = b % c;
+    /* we will iterate through all the bits of a from least to most
+     * significant, we can stop early once there are no set bits though */
+    while (a) {
+        /* If this bit is set then the power of two is part of the
+         * construction of a */
+        if (a & 1) {
+            /* increase final quotient, taking care of any remainder */
+            quotient += cur_quotient;
+            remainder += cur_remainder;
+            if (remainder >= c) {
+                quotient++;
+                remainder -= c;
+            }
+        }
+        /* Go to the next bit of a. Also means the effective quotient
+         * and remainder of our (b / c) needs increasing */
+        a >>= 1;
+        cur_quotient <<= 1;
+        cur_remainder <<= 1;
+        /* Keep the remainder sensible, otherewise the remainder check
+         * in the if (a & 1) case has to become a loop */
+        if (cur_remainder >= c) {
+            cur_quotient++;
+            cur_remainder -= c;
+        }
+    }
+    return quotient;
+}
+
+static inline uint64_t tsc_get_time(uint64_t freq)
+{
+    return muldivu64(rdtsc_pure(), NS_IN_S, freq);
+}
+
+
+#define RUNS 100
+static uint64_t results[RUNS][3];
+
+int main(int argc, char *argv[]) {
+
+    volatile int *stage = (int *) atol(argv[1]);
+    uint64_t period = atol(argv[2]);
+    seL4_CPtr ep = atol(argv[3]);
+    seL4_CPtr signal = atol(argv[4]);
+    uint64_t freq = atol(argv[5]);
+
+    char *mad_argv[] = {
+        "madplay",
+        "--time=30",
+        "--output=wave:/tmp/output_large.wav",
+        "-q",
+        "/data/mad/large.mp3"
+    };
+
+    (void) stage;
+    /* wait for the start signal */
+    seL4_SetMR(0, SET_TIMEOUT);
+    seL4_SetMR(1, TIMEOUT_PERIODIC);
+    seL4_SetMR(2, period);
+    seL4_Call(ep, seL4_MessageInfo_new(0xF00, 0, 0, 3));
+
+    seL4_Wait(signal, NULL);
+
+    int ret = 0;
+    for (int i = 0; i < RUNS; i++) {
+   		uint64_t start = tsc_get_time(freq);
+        uint64_t deadline = start + period;
+        results[i][0] = start;
+        results[i][1] = deadline;
+
+		ret |= mad_main(5, mad_argv);
+        uint64_t now = tsc_get_time(freq);
+        results[i][2] = now;
+        seL4_Wait(signal, NULL);
+	}
+
+  printf("Done, dumping results\n");
+
+    for (int i = 0; i < RUNS; i ++) {
+        /* we should always have met the deadline */
+      //  assert(results[i][1] > results[i][3]);
+        assert(results[i][2] > results[i][0]);
+        printf("MAD\t%lu\n", results[i][2] - results[i][0]);
+    }
+
+
+    return ret;
+}
